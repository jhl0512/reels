<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
  <title>Shorts</title>
  <link rel="stylesheet" href="youtube_sample_globals.css">
  <link rel="stylesheet" href="yotuube_sample.css">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: auto; /* <- 모바일에서 scroll 막히는 문제 방지 */
    }

    :root {
      --vh: 100vh;
    }

    #container {
      height: calc(var(--vh, 1vh) * 100);
      overflow-y: scroll;
      scroll-snap-type: y mandatory;
      -webkit-overflow-scrolling: touch;
    }

    #container::-webkit-scrollbar {
      display: none;
    }

    .video {
      scroll-snap-align: start;
      height: calc(var(--vh, 1vh) * 100);
      position: relative;
      overflow: hidden;
    }

    .video video.video-bg {
      position: absolute;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      z-index: 0;
      pointer-events: none;
    }

    .video > * { z-index: 1; position: relative; }
    #loading { text-align: center; padding: 8px; font-size: 0.9rem; color: #333; background: #fff; }
  </style>
  <script>
    // 모바일 주소창 제외한 실제 vh 계산
    function setVh() {
      let vh = window.innerHeight * 0.01;
      document.documentElement.style.setProperty('--vh', `${vh}px`);
    }
    window.addEventListener('resize', setVh);
    window.addEventListener('orientationchange', setVh);
    window.addEventListener('load', setVh);
  </script>
</head>
<body>
  <div id="container">
    <div class="video" id="video-template">
      <!-- 템플릿 콘텐츠 (SVG, UI 등 기존 코드 유지) -->
    </div>
    <div id="loading">로딩 중...</div>
  </div>

  <script>
    const categories = ['트와이스 다현', '땅울림'];
    const container = document.getElementById('container');
    const loading = document.getElementById('loading');
    const template = document.getElementById('video-template');
    template.removeAttribute('id');
    container.removeChild(template);

    function parseCSV(text) {
      const lines = text.trim().split('\n');
      const headers = lines[0].split(',').map(h => h.trim());
      return lines.slice(1).map(line => {
        const cols = line.split(',').map(c => c.trim());
        let o = {};
        headers.forEach((h, i) => o[h] = cols[i] || '');
        return o;
      });
    }

    function createPost(data) {
      const post = template.cloneNode(true);
      const bg = document.createElement('video');
      bg.className = 'video-bg';
      bg.src = data['MP4 URL'];
      bg.autoplay = true;
      bg.loop = true;
      bg.playsInline = true;
      bg.muted = true;
      post.prepend(bg);

      post.querySelector('.id-text').textContent = data['ID'];
      post.querySelector('.title-text').textContent = data['TITLE'];
      post.querySelector('.music-text').textContent = data['MUSIC'];
      return post;
    }

    async function loadAll() {
      for (const cat of categories) {
        try {
          const res = await fetch(`${cat}.csv`);
          if (!res.ok) throw new Error(cat + '.csv 로드 실패');
          const text = await res.text();
          parseCSV(text).forEach(row => container.appendChild(createPost(row)));
          updateAudio();
        } catch (err) {
          console.error(err);
        }
      }
      loading.style.display = 'none';
    }

    function updateAudio() {
      const videos = document.querySelectorAll('.video');
      const containerRect = container.getBoundingClientRect();
      videos.forEach(video => {
        const rect = video.getBoundingClientRect();
        const videoEl = video.querySelector('video');
        const fullyVisible = rect.top >= containerRect.top && rect.bottom <= containerRect.bottom;
        if (videoEl) {
          videoEl.muted = !fullyVisible;
          if (fullyVisible) videoEl.play();
          else videoEl.pause();
        }
      });
    }

    let isScrolling = false;
    container.addEventListener('wheel', (e) => {
      e.preventDefault();
      if (isScrolling) return;
      isScrolling = true;

      const direction = e.deltaY > 0 ? 1 : -1;
      const videos = [...container.querySelectorAll('.video')];
      const currentScroll = container.scrollTop;
      const viewHeight = container.clientHeight;

      let currentIndex = videos.findIndex(v => Math.abs(v.offsetTop - currentScroll) < viewHeight / 2);
      if (currentIndex === -1) currentIndex = Math.round(currentScroll / viewHeight);
      let targetIndex = Math.max(0, Math.min(videos.length - 1, currentIndex + direction));
      container.scrollTo({ top: videos[targetIndex].offsetTop, behavior: 'smooth' });

      setTimeout(() => {
        isScrolling = false;
        updateAudio();
      }, 600);
    }, { passive: false });

    container.addEventListener('scroll', () => {
      clearTimeout(container._scrollTimeout);
      container._scrollTimeout = setTimeout(updateAudio, 200);
    });

    loadAll();
  </script>
</body>
</html>
